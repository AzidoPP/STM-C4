主控STM32F103C8T6，使用keil5+stlink仿真器
外部8MHz高速晶振

1. 采用LCD1601A来代替原先的LCD1602A。为了还原外观，LCD1601A在板子上是倒置的，所以不能直接用原来从左往右和普通的字符。必须从右往左，并且所有字符都得旋转180度。比如说我想要用户能看到显示左对齐的ABCDEF，那么实际我需要显示的就是右对齐的FEDCBA，并且每个字符都得要自身旋转180度。
这里你可能需要一个完整的倒置的字符表，其实只需要用到这些数字的字符（倒置版）"0123456789*"好像就够了
LCD1601A需要采用4线模式
关于LCD1601A的引脚是这些
#define LCD_RS_PORT GPIOB
#define LCD_RS_PIN GPIO_Pin_12
#define LCD_EN_PORT GPIOB
#define LCD_EN_PIN GPIO_Pin_14

#define LCD_D4_PORT GPIOA
#define LCD_D4_PIN GPIO_Pin_4
#define LCD_D5_PORT GPIOA
#define LCD_D5_PIN GPIO_Pin_5
#define LCD_D6_PORT GPIOA
#define LCD_D6_PIN GPIO_Pin_6
#define LCD_D7_PORT GPIOA
#define LCD_D7_PIN GPIO_Pin_7
LCD1601A采用5V电平，外部我接了上拉到5V的上拉电阻，所以信号脚需要用开漏输出

#define LCD_BLED_PORT GPIOA
#define LCD_BLED_PIN GPIO_Pin_3 (LCD背光板LED，高电平点亮，推挽)

参考代码：#include "1601a.h"
#include "stm32f10x_rcc.h"
#include "delay.h"

static void LCD_SetDataNibble(uint8_t data)
{
	if (data & 0x01) { GPIO_SetBits(LCD_D4_PORT, LCD_D4_PIN); } else { GPIO_ResetBits(LCD_D4_PORT, LCD_D4_PIN); }
	if (data & 0x02) { GPIO_SetBits(LCD_D5_PORT, LCD_D5_PIN); } else { GPIO_ResetBits(LCD_D5_PORT, LCD_D5_PIN); }
	if (data & 0x04) { GPIO_SetBits(LCD_D6_PORT, LCD_D6_PIN); } else { GPIO_ResetBits(LCD_D6_PORT, LCD_D6_PIN); }
	if (data & 0x08) { GPIO_SetBits(LCD_D7_PORT, LCD_D7_PIN); } else { GPIO_ResetBits(LCD_D7_PORT, LCD_D7_PIN); }
}

static void LCD_PulseEnable(void)
{
	GPIO_SetBits(LCD_EN_PORT, LCD_EN_PIN);
	Delay_us(1);
	GPIO_ResetBits(LCD_EN_PORT, LCD_EN_PIN);
	Delay_us(50);
}

static void LCD_Write4Bits(uint8_t nibble)
{
	LCD_SetDataNibble(nibble & 0x0F);
	LCD_PulseEnable();
}

static void LCD_Write8Bits(uint8_t value)
{
	LCD_Write4Bits(value >> 4);
	LCD_Write4Bits(value & 0x0F);
}

void GPIO_INIT(void)
{
	GPIO_InitTypeDef gpio;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);

	gpio.GPIO_Pin = LCD_RS_PIN | LCD_EN_PIN;
	gpio.GPIO_Mode = GPIO_Mode_Out_OD;
	gpio.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &gpio);

	gpio.GPIO_Pin = LCD_DATA_PORTA_PINS;
	gpio.GPIO_Mode = GPIO_Mode_Out_OD;
	gpio.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &gpio);

	gpio.GPIO_Pin = GPIO_Pin_3;
	gpio.GPIO_Mode = GPIO_Mode_Out_PP;
	gpio.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &gpio);
	GPIO_SetBits(GPIOA, GPIO_Pin_3);
}

void LCD_INIT(void)
{
	GPIO_INIT();

	GPIO_ResetBits(LCD_RS_PORT, LCD_RS_PIN);
	GPIO_ResetBits(LCD_EN_PORT, LCD_EN_PIN);

	Delay_ms(20);
	LCD_Write4Bits(0x03);
	Delay_ms(5);
	LCD_Write4Bits(0x03);
	Delay_ms(5);
	LCD_Write4Bits(0x03);
	Delay_ms(1);
	LCD_Write4Bits(0x02);

	LCD_WRITE_CMD(0x28);
	LCD_WRITE_CMD(0x08);
	LCD_WRITE_CMD(0x01);
	Delay_ms(2);
	LCD_WRITE_CMD(0x06);
	LCD_WRITE_CMD(0x0C);
}

void LCD_WRITE_CMD(unsigned char CMD)
{
	GPIO_ResetBits(LCD_RS_PORT, LCD_RS_PIN);
	LCD_Write8Bits(CMD);
	if (CMD == 0x01 || CMD == 0x02)
	{
		Delay_ms(2);
	}
	else
	{
		Delay_us(50);
	}
}

void LCD_WRITE_ByteDATA(unsigned char ByteData)
{
	GPIO_SetBits(LCD_RS_PORT, LCD_RS_PIN);
	LCD_Write8Bits(ByteData);
	Delay_us(50);
}

void LCD_SetCursor(unsigned char Column)
{
	if (Column <= 7)
	{
		LCD_WRITE_CMD(0x80 | Column);
	}
	else
	{
		LCD_WRITE_CMD(0x80 | (Column - 8) + 0x40);
	}
}

void LCD_WRITE_StrDATA(unsigned char *StrData, unsigned char col)
{
	unsigned char i;

	for (i = 0; StrData[i] != '\0'; i++)
	{
		LCD_SetCursor(col);
		LCD_WRITE_ByteDATA(StrData[i]);
		col++;
	}
}

void WUserImg(unsigned char pos, unsigned char *ImgInfo)
{
	unsigned char cgramAddr;

	if (pos <= 1) cgramAddr = 0x40;
	if (pos > 1 && pos <= 3) cgramAddr = 0x50;
	if (pos > 3 && pos <= 5) cgramAddr = 0x60;
	if (pos > 5 && pos <= 7) cgramAddr = 0x70;

	LCD_WRITE_CMD((cgramAddr + (pos % 2) * 8));

	while (*ImgInfo != '\0')
	{
		LCD_WRITE_ByteDATA(*ImgInfo);
		ImgInfo++;
	}
}


2. 矩阵键盘
PB15 PB4 PB5 PB6 PB7 PB8 PB9
排列为：
        PB5     PB15    PB7
PB4     [1]     [2]     [3]
PB9     [4]     [5]     [6]
PB8     [7]     [8]     [9]
PB6     [*]     [0]     [#]


3. 蜂鸣器
无源蜂鸣器（已包含驱动电路，mos管，栅极10k下拉，栅极连接PB0）
PB0发出PWM波驱动

4. LED
PC13-系统指示LED（一般不用，调试才用）（推挽高电平点亮）

用户指示双色LED（推挽高电平点亮）
PA2-红
PA1-绿
如果需要黄色就要红绿同时点亮PA2和PA1，并且需要PWM调节（比如黄色100%的时候，红色大约是70%，绿色100%，因为人眼对红色感度比绿色高。输出黄色50，红色35%，绿色50%）

5. 继电器（已包含mos+续流驱动电路）
PB1高电平-继电器吸合

6. MP3模块。
PA9串口通讯，用来播放C4模型的音乐盒或者音效
参考代码：
#include "stm32f10x.h"                  // Device header
#include <stdio.h>
#include <stdarg.h>

/**
  * 函    数：串口初始化
  * 参    数：无
  * 返 回 值：无
  */
void Serial_Init(void)
{
	/*开启时钟*/
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);	//开启USART1的时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);	//开启GPIOA的时钟
	
	/*GPIO初始化*/
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);					//将PA9引脚初始化为复用推挽输出
	
	/*USART初始化*/
	USART_InitTypeDef USART_InitStructure;					//定义结构体变量
	USART_InitStructure.USART_BaudRate = 9600;				//波特率
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;	//硬件流控制，不需要
	USART_InitStructure.USART_Mode = USART_Mode_Tx;			//模式，选择为发送模式
	USART_InitStructure.USART_Parity = USART_Parity_No;		//奇偶校验，不需要
	USART_InitStructure.USART_StopBits = USART_StopBits_1;	//停止位，选择1位
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;		//字长，选择8位
	USART_Init(USART1, &USART_InitStructure);				//将结构体变量交给USART_Init，配置USART1
	
	/*USART使能*/
	USART_Cmd(USART1, ENABLE);								//使能USART1，串口开始运行
}



/**
  * 函    数：串口发送一个字节
  * 参    数：Byte 要发送的一个字节
  * 返 回 值：无
  */
void Serial_SendByte(uint8_t Byte)
{
	USART_SendData(USART1, Byte);		//将字节数据写入数据寄存器，写入后USART自动生成时序波形
	while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);	//等待发送完成
	/*下次写入数据寄存器会自动清除发送完成标志位，故此循环后，无需清除标志位*/
}



/**
  * 函    数：串口发送一个数组
  * 参    数：Array 要发送数组的首地址
  * 参    数：Length 要发送数组的长度
  * 返 回 值：无
  */
void Serial_SendArray(uint8_t *Array, uint16_t Length)
{
	uint16_t i;
	for (i = 0; i < Length; i ++)		//遍历数组
	{
		Serial_SendByte(Array[i]);		//依次调用Serial_SendByte发送每个字节数据
	}
}



/**
  * 函    数：串口发送一个字符串
  * 参    数：String 要发送字符串的首地址
  * 返 回 值：无
  */
void Serial_SendString(char *String)
{
	uint8_t i;
	for (i = 0; String[i] != '\0'; i ++)//遍历字符数组（字符串），遇到字符串结束标志位后停止
	{
		Serial_SendByte(String[i]);		//依次调用Serial_SendByte发送每个字节数据
	}
}



/**
  * 函    数：次方函数（内部使用）
  * 返 回 值：返回值等于X的Y次方
  */
uint32_t Serial_Pow(uint32_t X, uint32_t Y)
{
	uint32_t Result = 1;	//设置结果初值为1
	while (Y --)			//执行Y次
	{
		Result *= X;		//将X累乘到结果
	}
	return Result;
}

/**
  * 函    数：串口发送数字
  * 参    数：Number 要发送的数字，范围：0~4294967295
  * 参    数：Length 要发送数字的长度，范围：0~10
  * 返 回 值：无
  */
void Serial_SendNumber(uint32_t Number, uint8_t Length)
{
	uint8_t i;
	for (i = 0; i < Length; i ++)		//根据数字长度遍历数字的每一位
	{
		Serial_SendByte(Number / Serial_Pow(10, Length - i - 1) % 10 + '0');	//依次调用Serial_SendByte发送每位数字
	}
}

/**
  * 函    数：使用printf需要重定向的底层函数
  * 参    数：保持原始格式即可，无需变动
  * 返 回 值：保持原始格式即可，无需变动
  */
int fputc(int ch, FILE *f)
{
	Serial_SendByte(ch);			//将printf的底层重定向到自己的发送字节函数
	return ch;
}

/**
  * 函    数：自己封装的prinf函数
  * 参    数：format 格式化字符串
  * 参    数：... 可变的参数列表
  * 返 回 值：无
  */
void Serial_Printf(char *format, ...)
{
	char String[100];				//定义字符数组
	va_list arg;					//定义可变参数列表数据类型的变量arg
	va_start(arg, format);			//从format开始，接收参数列表到arg变量
	vsprintf(String, format, arg);	//使用vsprintf打印格式化字符串和参数列表到字符数组中
	va_end(arg);					//结束变量arg
	Serial_SendString(String);		//串口发送字符数组（字符串）
}

#include "stm32f10x.h"
#include "Serial.h"
#include "delay.h"




/*
音乐序号  音乐名
			0	  虚空
			1	  军团
			2	  新黑色电影
			3	  困兽
			4	  神枪手
			5   追溯起源
			6   竞技场
			7		冲破藩篱
			8		咄咄逼人
			9		哥特浮华
			10	大胆尝试
			11	GLA
			12		漂泊者
			13		战火星空
			14	黄色魔法
			15	巨龙之眼
			16	咖啡拉花
			17	巴克拉姆
			18	电锯追命
			19	决心
			20	燥起来
			21	尘归尘
			22	A.D.8
			23	疤王
			24	万夫莫敌包
			25	终极
			26	大局入侵
			27	同型节奏
			28	地球末夜
			29	莫洛托夫烈火
			30	无人之境
			31	理由
			32	精彩时刻
			33	超爆话筒
			34	叛乱
			35	雄狮之口
			36	沙漠之焰
			37	好好干，好好活
			38	深红突击
			39	骷髅爆破
			40	绝对统御
			41	金属
			42	如日中天
			43	永恒之钻
			44	圣诞之歌
			45	你急了
			46	蜂鸟
			47	海绵手指
			48	8位音乐盒
			49	迈阿密热线
			50	令人发指
			51	躺平青年
			52	爆头
			53	闪光舞
			54	尖峰时刻
			55	塔罗斯的法则
			56	有害物质环境
			57	就是我
			58	EZ4ENCE
			59	爪哇哈瓦那放克乐
			60	触摸能量
			61	通宵达旦
			62	非人类
			63	花脸
			64	征服
			65	万众瞩目
			66	冲击星
			67	人生何处不青山
			68	枪炮卷饼卡车
			69	有为青年
			70	光环：士官长合集
			71	黑帝斯音乐盒
			72	反叛者
			73	Ben Bromfield,Rabbit Hole
			74	Daniel Sadowski,Dead Shot
			75	Sam Marshall,Clutch
			76	Tree Adams,Seventh Moon
			77	Tim Huling,Devil's Paintbrush
			78	Dren McDonald,Coffee!Kofe Kahveh!
			79	Matt Levine,Agency
			80	Austin Wintory,The Devil Went Clubbing in Georgia
			81	诶嘿
			
			
			
			82 c4上电下包
			83 c4下包完成
			84 c4倒计时结束爆炸_完整


*/
#include "stm32f10x.h"
#include "Serial.h"

uint8_t Send_buf[10];
void MP3CMD(uint8_t CMD , uint16_t data)
{

    Send_buf[0] = 0x7e;    //头
    Send_buf[1] = 0xff;    //保留字节 
    Send_buf[2] = 0x06;    //长度
    Send_buf[3] = CMD;     //控制指令
    Send_buf[4] = 0x00;    //是否需要反馈
	Send_buf[5] = (uint8_t)(data >> 8);    //data
    Send_buf[6] = (uint8_t)(data);   //data
	Send_buf[7] = ((~(0xff+0x06+CMD+data))+1) >> 8;    //校验和
	Send_buf[8] = ((~(0xff+0x06+CMD+data))+1)&0x00ff;//校验和
    Send_buf[9] = 0xef;    //尾
	
	for (u8 i = 0; i < 10; i ++)		//遍历数组
	{
		Serial_SendByte(Send_buf[i]);	  //依次调用Serial_SendByte发送每个字节数据
	}
	

}


void mp3_Init(void)
{
	Serial_Init();
}

void mp3_start(void)//上电提示音
{
	MP3CMD(0x12,100);
}

void mp3_over(void)//下包结束音
{
	MP3CMD(0x12,101);  
}

void mp3_boom(void)//c4爆炸音
{
	MP3CMD(0x12,102);
}

void mp3_boom_music(void)//默认播放02文件夹内000xxx.MP3歌曲
{
	
//	MP3CMD(0x0f,0x0251);
	
	Send_buf[0] = 0x7e;    //头
    Send_buf[1] = 0xff;    //保留字节 
    Send_buf[2] = 0x06;    //长度
    Send_buf[3] = 0x0f;     //控制指令
    Send_buf[4] = 0x00;    //是否需要反馈
	Send_buf[5] = 0x02;    //data
    Send_buf[6] = 0x00;
	Send_buf[7] = 0xfe;
	Send_buf[8] = 0xea;
    Send_buf[9] = 0xef;    //尾
	
	for (u8 i = 0; i < 10; i ++)		//遍历数组
	{
		Serial_SendByte(Send_buf[i]);	  //依次调用Serial_SendByte发送每个字节数据
	}

}

7. 外部“拆弹器”
PB3上拉输入，如果下拉就进入“拆弹器拆弹模式”，拆弹时间只需要5秒，也就是PB3连续外部下拉5秒，就算拆弹成功

流程：

LED先是黄色呼吸灯模式，周期500ms
上电后先快速哔哔两声以4250Hz。


然后等待输入密码，密码7位数，输入7位数后先不要直接立马进入倒计时模式，而是多等待一会防止用户最后一位数输错了。然后记录此密码（输入密码的时候LED依然是呼吸灯模式）
然后进入倒计时模式，倒计时按照原版的时间和pattern来。每次beep的时候LED亮红色，不beep的时候LED熄灭
In short, here is the formula for the beep pattern of the CS:GO bomb:

f(t) = 1.05 · exp(0.0054t + 0.000871t²)

Where f(t) gives the BPS (Beeps Per Second), and t (0 ≤ t ≤ 45) is the time in seconds (the in-game bomb explodes after 45 seconds).

For a more generalized formula:

g(p) = 1.049 · exp(0.244p + 1.764p²)

Where g(p) gives the BPS (Beeps Per Second), and p (0.0 ≤ p ≤ 1.0) is the percentage of the time that has passed since the bomb has been armed. This is more useful when you don’t want to be stuck using the 45 second explosion time frame.

The length of each beep is fixed at 125ms per beep. These formulas approximate the beep pattern of CS:GO’s bomb very accurately.

If anyone has ever wondered what the formula for the bomb beeping interval is..

Thanks to the code leak

freq = MAX( 0.1 + 0.9 * fComplete, 0.15 );

where fComplete is the percentage of the time that's left (40/40 when planted and 0/40 at the end)

When the bomb is planted, it sets the time for the next beep to gpGlobals->curtime + 1.0...

倒计时的时候LCD1601A显示滚动的“*”号。原来的实现是这样：void TIM2_IRQHandler(void)//中断函数，每秒执行20次
{
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)
	{
		if(Num_sign == 0)
		{
			Num ++;											
			TIM_ClearITPendingBit(TIM2, TIM_IT_Update);	
			if(Num>=13){Num_sign=1;}
		}
		else
		{
			Num --;											
			TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
			if(Num<=0){Num_sign=0;}
		}
	}
}
void lcdupdate(void)
{
	static int dt=0;
	static char lcdtp=0;
	dt++;
	if(dt>=30000)
	{
		switch(lcdtp)
		{
			case 0:
				LCD_WRITE_StrDATA("*            ",0);
				lcdtp++;
				break;
			case 1:
				LCD_WRITE_StrDATA(" *           ",0);
				lcdtp++;
				break;
			case 2:
				LCD_WRITE_StrDATA("  *          ",0);
				lcdtp++;
				break;
			case 3:
				LCD_WRITE_StrDATA("   *         ",0);
				lcdtp++;
				break;
			default:
				LCD_WRITE_StrDATA("    *        ",0);
				lcdtp=0;
				break;
		}
		dt=0;
	}
}
要注意，现在LCD1601A是反装的，所以符号啊，位置啊都要翻转180度

倒计时过程中拆弹有3种情况：（并且都要非阻塞，比如就算拆弹失败或者拆弹过程中，倒计时的时间什么的都不能变，之前老版本的因为扫描键盘和倒计时循环都是阻塞的导致如果长按某个按键，会因为按键消抖延时的问题导致倒计时的循环时间不准确）
1. 直接输入密码，直接按键盘输入和下包一样的密码，则为拆弹成功
2. 长按#进入破解手动拆弹模式，耗时10秒必能成功拆除，拆弹的动画是每一位数字从0123456789跳变10次，然后定格在正确的那位数，然后再是下一位跳变，然后定格，下一位，每次只“爆破”一位数，直到完整的密码显现出来。
3. 拆弹器拆弹，动画和手动爆破拆弹一样，但是速度快一倍，只需5秒就能拆包。
注意，输入密码的数字出现顺序和拆弹的数字输入左右顺序不一样，可以参考原先的代码你就懂了。
拆弹成功会播放拆弹成功效果

如果倒计时结束而没有拆弹，那么继电器吸合，然后播放音效和音乐盒，同时LED输出100%黄色（LED和播放音乐盒同时）。

参考老版代码。
现在这个工程有一些是最早的V1.0（没有MP3并且是1602）V2.0、V3.0代码（后续更新的一些，比如改成了1601A但是8线模式，添加了MP3这些）的混合，所以你大概需要全部重写一下了。


